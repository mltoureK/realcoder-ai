=== FUNCTION EXTRACTION & QUESTION GENERATION LOG ===
Session ID: session-1760067316498
Started: 2025-10-10T03:35:16.498Z


--- FUNCTION EXTRACTION ---
Timestamp: 2025-10-10T03:35:16.499Z
File: the API is ~stable, so this should be fine
Functions Extracted: 2


Function 1: closeSpanWithError
Language: TypeScript
Lines: 10
Full Code:
--------------------------------------------------------------------------------
const closeSpanWithError = (span: Span, error?: Error) => {
  if (isBubbledError(error) && error.bubble) {
    span.setAttribute('next.bubble', true)
  } else {
    if (error) {
      span.recordException(error)
      span.setAttribute('error.type', error.name)
    }
    span.setStatus({ code: SpanStatusCode.ERROR, message: error?.message })
  }
  span.end()
}
--------------------------------------------------------------------------------


Function 2: getTracePropagationData
Language: TypeScript
Lines: 6
Full Code:
--------------------------------------------------------------------------------
public getTracePropagationData(): ClientTraceDataEntry[] {
    const activeContext = context.active()
    const entries: ClientTraceDataEntry[] = []
    propagation.inject(activeContext, entries, clientTraceDataSetter)
    return entries
}
--------------------------------------------------------------------------------

================================================================================

--- FUNCTION EXTRACTION ---
Timestamp: 2025-10-10T03:35:27.834Z
File: vercel-next.js-0a7811c/packages/next/src/compiled/@edge-runtime/cookies/index.d.ts
Functions Extracted: 3


Function 1: stringifyCookie
Language: TypeScript
Lines: 8
Full Code:
--------------------------------------------------------------------------------
declare function stringifyCookie(c: ResponseCookie | RequestCookie): string {
    const pairs = [];
    for (const [key, value] of Object.entries(c)) {
        if (key !== 'expires' && value !== undefined) {
            pairs.push(`${key}=${encodeURIComponent(value)}`);
        }
    }
    return pairs.join('; ');
}
--------------------------------------------------------------------------------


Function 2: parseCookie
Language: TypeScript
Lines: 8
Full Code:
--------------------------------------------------------------------------------
declare function parseCookie(cookie: string): Map<string, string> {
    const result = new Map<string, string>();
    const cookies = cookie.split('; ');
    for (const cookie of cookies) {
        const [name, value] = cookie.split('=').map(decodeURIComponent);
        result.set(name, value);
    }
    return result;
}
--------------------------------------------------------------------------------


Function 3: parseSetCookie
Language: TypeScript
Lines: 12
Full Code:
--------------------------------------------------------------------------------
declare function parseSetCookie(setCookie: string): undefined | ResponseCookie {
    const cookieParts = setCookie.split('; ');
    const [nameValue, ...attributes] = cookieParts;
    const [name, value] = nameValue.split('=').map(decodeURIComponent);
    const cookie: ResponseCookie = { name, value };
    for (const attr of attributes) {
        const [key, val] = attr.split('=').map(decodeURIComponent);
        if (key in cookie) {
            cookie[key] = val;
        }
    }
    return cookie;
}
--------------------------------------------------------------------------------

================================================================================

--- FUNCTION EXTRACTION ---
Timestamp: 2025-10-10T03:35:48.284Z
File: @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BufferSource'.
Functions Extracted: 4


Function 1: buildEnvironmentVariablesFrom
Language: TypeScript
Lines: 10
Full Code:
--------------------------------------------------------------------------------
function buildEnvironmentVariablesFrom(
  injectedEnvironments: Record<string, string>
): Record<string, string | undefined> {
  const pairs = Object.keys(process.env).map((key) => [key, process.env[key]])
  const env = Object.fromEntries(pairs)
  for (const key of Object.keys(injectedEnvironments)) {
    env[key] = injectedEnvironments[key]
  }
  env.NEXT_RUNTIME = 'edge'
  return env
}
--------------------------------------------------------------------------------


Function 2: throwUnsupportedAPIError
Language: TypeScript
Lines: 6
Full Code:
--------------------------------------------------------------------------------
function throwUnsupportedAPIError(name: string) {
  const error =
    new Error(`A Node.js API is used (${name}) which is not supported in the Edge Runtime.
Learn more: https://nextjs.org/docs/api-reference/edge-runtime`)
  decorateServerError(error, COMPILER_NAMES.edgeServer)
  throw error
}
--------------------------------------------------------------------------------


Function 3: createProcessPolyfill
Language: TypeScript
Lines: 17
Full Code:
--------------------------------------------------------------------------------
function createProcessPolyfill(env: Record<string, string>) {
  const processPolyfill = { env: buildEnvironmentVariablesFrom(env) }
  const overriddenValue: Record<string, any> = {}

  for (const key of Object.keys(process)) {
    if (key === 'env') continue
    Object.defineProperty(processPolyfill, key, {
      get() {
        if (overriddenValue[key] !== undefined) {
          return overriddenValue[key]
        }
        if (typeof (process as any)[key] === 'function') {
          return () => throwUnsupportedAPIError(`process.${key}`)
        }
        return undefined
      },
      set(value) {
        overriddenValue[key] = value
      },
      enumerable: false,
    })
  }
  return processPolyfill
}
--------------------------------------------------------------------------------


Function 4: createModuleContext
Language: TypeScript
Lines: 42
Full Code:
--------------------------------------------------------------------------------
async function createModuleContext(options: ModuleContextOptions) {
  const warnedEvals = new Set<string>()
  const warnedWasmCodegens = new Set<string>()
  const { edgeFunctionEntry } = options
  const wasm = await loadWasm(edgeFunctionEntry.wasm ?? [])
  const runtime = new EdgeRuntime({
    codeGeneration:
      process.env.NODE_ENV !== 'production'
        ? { strings: true, wasm: true }
        : undefined,
    extend: (context) => {
      context.process = createProcessPolyfill(edgeFunctionEntry.env)

      Object.defineProperty(context, 'require', {
        enumerable: false,
        value: (id: string) => {
          const value = NativeModuleMap.get(id)
          if (!value) {
            throw TypeError('Native module not found: ' + id)
          }
          return value
        },
      })

      if (process.env.NODE_ENV !== 'production') {
        context.__next_log_error__ = function (err: unknown) {
          options.onError(err)
        }
      }

      context.__next_eval__ = function __next_eval__(fn: Function) {
        const key = fn.toString()
        if (!warnedEvals.has(key)) {
          const warning = getServerError(
            new Error(
              `Dynamic Code Evaluation (e. g. 'eval', 'new Function') not allowed in Edge Runtime
Learn More: https://nextjs.org/docs/messages/edge-dynamic-code-evaluation`
            ),
            COMPILER_NAMES.edgeServer
          )
          warning.name = 'DynamicCodeEvaluationWarning'
          Error.captureStackTrace(warning, __next_eval__)
          warnedEvals.add(key)
          options.onWarning(warning)
        }
        return fn()
      }

      context.__next_webassembly_compile__ =
        function __next_webassembly_compile__(fn: Function) {
          const key = fn.toString()
          if (!warnedWasmCodegens.has(key)) {
            const warning = getServerError(
              new Error(`Dynamic WASM code generation (e. g. 'WebAssembly.compile') not allowed in Edge Runtime.
Learn More: https://nextjs.org/docs/messages/edge-dynamic-code-evaluation`),
              COMPILER_NAMES.edgeServer
            )
            warning.name = 'DynamicWasmCodeGenerationWarning'
            Error.captureStackTrace(warning, __next_webassembly_compile__)
            warnedWasmCodegens.add(key)
            options.onWarning(warning)
          }
          return fn()
        }

      context.__next_webassembly_instantiate__ =
        async function __next_webassembly_instantiate__(fn: Function) {
          const result = await fn()
--------------------------------------------------------------------------------

================================================================================

--- FUNCTION EXTRACTION ---
Timestamp: 2025-10-10T03:35:53.170Z
File: This keeps autocompletion working for static routes.
Functions Extracted: 1


Function 1: generateValidatorFile
Language: TypeScript
Lines: 15
Full Code:
--------------------------------------------------------------------------------
export function generateValidatorFile(
  routesManifest: RouteTypesManifest
): string {
  const generateValidations = (
    paths: string[],
    type:
      | 'AppPageConfig'
      | 'PagesPageConfig'
      | 'LayoutConfig'
      | 'RouteHandlerConfig'
      | 'ApiRouteConfig',
    pathToRouteMap?: Map<string, string>
  ) =>
    paths
      .sort()
      .map((path) => {
        const route = pathToRouteMap ? pathToRouteMap.get(path) : undefined;
        return `Validation for ${path} of type ${type} with route ${route}`;
      });

  return 'Validator file generated';
}
--------------------------------------------------------------------------------

================================================================================

--- FUNCTION EXTRACTION ---
Timestamp: 2025-10-10T03:36:48.430Z
File: vercel-next.js-0a7811c/packages/next/src/server/route-modules/route-module.ts
Functions Extracted: 2


Function 1: instrumentationOnRequestError
Language: TypeScript
Lines: 25
Full Code:
--------------------------------------------------------------------------------
public async instrumentationOnRequestError(
    req: IncomingMessage | BaseNextRequest,
    ...args: Parameters<InstrumentationOnRequestError>
  ) {
    if (process.env.NEXT_RUNTIME === 'edge') {
      const { getEdgeInstrumentationModule } = await import('../web/globals')
      const instrumentation = await getEdgeInstrumentationModule()

      if (instrumentation) {
        await instrumentation.onRequestError?.(...args)
      }
    } else {
      const { join } = require('node:path') as typeof import('node:path')
      const absoluteProjectDir = join(
        /* turbopackIgnore: true */
        process.cwd(),
        getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir
      )

      const { instrumentationOnRequestError } = await import(
        '../lib/router-utils/instrumentation-globals.external.js'
      )

      return instrumentationOnRequestError(
        absoluteProjectDir,
        this.distDir,
        ...args
      )
    }
  }
--------------------------------------------------------------------------------


Function 2: loadManifests
Language: TypeScript
Lines: 66
Full Code:
--------------------------------------------------------------------------------
private loadManifests(
    srcPage: string,
    projectDir?: string
  ): {
    buildId: string
    buildManifest: BuildManifest
    fallbackBuildManifest: BuildManifest
    routesManifest: DeepReadonly<DevRoutesManifest>
    nextFontManifest: DeepReadonly<NextFontManifest>
    prerenderManifest: DeepReadonly<PrerenderManifest>
    serverFilesManifest: RequiredServerFilesManifest
    reactLoadableManifest: DeepReadonly<ReactLoadableManifest>
    subresourceIntegrityManifest: any
    clientReferenceManifest: any
    serverActionsManifest: any
    dynamicCssManifest: any
    interceptionRoutePatterns: RegExp[]
  } {
    if (process.env.NEXT_RUNTIME === 'edge') {
      const { getEdgePreviewProps } =
        require('../web/get-edge-preview-props') as typeof import('../web/get-edge-preview-props')

      const maybeJSONParse = (str?: string) =>
        str ? JSON.parse(str) : undefined

      return {
        buildId: process.env.__NEXT_BUILD_ID || '',
        buildManifest: self.__BUILD_MANIFEST as any,
        fallbackBuildManifest: {} as any,
        reactLoadableManifest: maybeJSONParse(self.__REACT_LOADABLE_MANIFEST),
        nextFontManifest: maybeJSONParse(self.__NEXT_FONT_MANIFEST),
        prerenderManifest: {
          routes: {},
          dynamicRoutes: {},
          notFoundRoutes: [],
          version: 4,
          preview: getEdgePreviewProps(),
        },
        routesManifest: {
          version: 4,
          caseSensitive: Boolean(process.env.__NEXT_CASE_SENSITIVE_ROUTES),
          basePath: process.env.__NEXT_BASE_PATH || '',
          rewrites: (process.env.__NEXT_REWRITES as any) || {
            beforeFiles: [],
            afterFiles: [],
            fallback: [],
          },
          redirects: [],
          headers: [],
          i18n:
            (process.env.__NEXT_I18N_CONFIG as any as I18NConfig) || undefined,
          skipMiddlewareUrlNormalize: Boolean(
            process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE
          ),
        },
        serverFilesManifest: {
          config: (globalThis as any).nextConfig || {},
        } as any,
        clientReferenceManifest: self.__RSC_MANIFEST?.[srcPage],
        serverActionsManifest: maybeJSONParse(self.__RSC_SERVER_MANIFEST),
        subresourceIntegrityManifest: maybeJSONParse(
          self.__SUBRESOURCE_INTEGRITY_MANIFEST
        ),
        dynamicCssManifest: maybeJSONParse(self.__DYNAMIC_CSS_MANIFEST),
        interceptionRoutePatterns: (
          maybeJSONParse(self.__INTERCEPTION_ROUTE_REWRITE_MANIFEST) ?? []
        ).map((rewrite: any) => new RegExp(rewrite.regex)),
      }
    } else {
      if (!projectDir) {
        throw new Error('Invariant: projectDir is required for node runtime')
      }
      const { loadManifestFromRelativePath } =
        require('../load-manifest.external') as typeof import('../load-manifest.external')
      const normalizedPagePath = normalizePagePath(srcPage)

      const router =
        this.definition.kind === RouteKind.PAGES ||
        this.definition.kind === RouteKind.PAGES_API
          ? 'pages'
          : 'app'

      const [
        routesManifest,
        prerenderManifest,
        buildManifest,
        fallbackBuildManifest,
        reactLoadableManifest,
        nextFontManifest,
        clientReferenceManifest,
        serverActionsManifest,
        subresourceIntegrityManifest,
        serverFilesManifest,
        buildId,
        dynamicCssManifest,
      ] = [
        loadManifestFromRelativePath<DevRoutesManifest>({
          projectDir,
          distDir: this.distDir,
          manifest: ROUTES_MANIFEST,
          shouldCache: !this.isDev,
        }),
        loadManifestFromRelativePath<PrerenderManifest>({
          projectDir,
          distDir: this.distDir,
          manifest: PRERENDER_MANIFEST,
          shouldCache: !this.isDev,
        }),
        loadManifestFromRelativePath<BuildManifest>({
          projectDir,
          distDir: this.distDir,
          manifest: BUILD_MANIFEST,
          shouldCache: !this.isDev,
        }),
        srcPage === '/_error'
          ? loadManifestFromRelativePath<BuildManifest>({
              projectDir,
              distDir: this.distDir,
              manifest: `fallback-${BUILD_MANIFEST}`,
              shouldCache: !this.isDev,
              handleMissing: true,
            })
          : ({} as BuildManifest),
        loadManifestFromRelativePath<ReactLoadableManifest>({
          projectDir,
          distDir: this.distDir,
          manifest: process.env.TURBOPACK
            ? `server/${router === 'app' ? 'app' : 'pages'}${normalizedPagePath}/${REACT_LOADABLE_MANIFEST}`
            : REACT_LOADABLE_MANIFEST,
          handleMissing: true,
          shouldCache: !this.isDev,
        }),
        loadManifestFromRelativePath<NextFontManifest>({
          projectDir,
          distDir: this.distDir,
          manifest: `server/${NEXT_FONT_MANIFEST}.json`,
          shouldCache: !this.isDev,
        }),
        router === 'app' && !isStaticMetadataRoute(srcPage)
          ? loadManifestFromRelativePath({
              distDir: this.distDir,
              projectDir,
              useEval: true,
              handleMissing: true,
              manifest: `server/app${srcPage.replace(/%5F/g, '_') + '_' + CLIENT_REFERENCE_MANIFEST}.js`,
              shouldCache: !this.isDev,
            })
          : undefined,
        router === 'app'
          ? loadManifestFromRelativePath<any>({
              distDir: this.distDir,
              projectDir,
              manifest: `server/${SERVER_REFERENCE_MANIFEST}.json`,
              handleMissing: true,
              shouldCache: !this.isDev,
            })
          : {},
        loadManifestFromRelativePath<Record<string, string>>({
          projectDir,
          distDir: this.distDir,
          manifest: `server/${SUBRESOURCE_INTEGRITY_MANIFEST}.json`,
          handleMissing: true,
          shouldCache: !this.isDev,
        }),
        this.isDev
          ? ({} as any)
          : loadManifestFromRelativePath<RequiredServerFilesManifest>({
              projectDir,
              distDir: this.distDir,
              manifest: SERVER_FILES_MANIFEST,
            }),
        this.isDev
          ? 'development'
          : loadManifestFromRelativePath<any>({
              projectDir,
              distDir: this.distDir,
              manifest: BUILD_ID_FILE,
              skipParse: true,
            }),
        loadManifestFromRelativePath<any>({
          projectDir,
          distDir: this.distDir,
          manifest: DYNAMIC_CSS_MANIFEST,
          handleMissing: true,
        }),
      ]

      return {
        buildId,
        buildManifest,
        fallbackBuildManifest,
        routesManifest,
        nextFontManifest,
        prerenderManifest,
        serverFilesManifest,
        reactLoadableManifest,
        clientReferenceManifest: (clientReferenceManifest as any)
          ?.__RSC_MANIFEST?.[srcPage.replace(/%5F/g, '_')],
        serverActionsManifest,
        subresourceIntegrityManifest,
        dynamicCssManifest,
        interceptionRoutePatterns: routesManifest.rewrites.beforeFiles
          .filter(isInterceptionRouteRewrite)
          .map((rewrite) => new RegExp(rewrite.regex)),
      }
    }
  }
--------------------------------------------------------------------------------

================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T03:36:57.265Z
Question Type: select-all
Function: getTracePropagationData
Function Size: 359 characters
Questions Generated: 1
Repository: Unknown
Function Preview: // Function: getTracePropagationData (TypeScript)\n// Injects the current context into a carrier for trace propagation.\n\npublic getTracePropagationData(): ClientTraceDataEntry[] {\n    const activeContext = context.active()\n    const entries: ClientTraceDataEntry[] = []\n    propagation.inject(activeCo
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T03:36:59.750Z
Question Type: select-all
Function: createProcessPolyfill
Function Size: 827 characters
Questions Generated: 1
Repository: Unknown
Function Preview: // Function: createProcessPolyfill (TypeScript)\n// Creates a polyfill for the process object in Edge Runtime\n\nfunction createProcessPolyfill(env: Record<string, string>) {\n  const processPolyfill = { env: buildEnvironmentVariablesFrom(env) }\n  const overriddenValue: Record<string, any> = {}\n\n  for (
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T03:37:02.662Z
Question Type: select-all
Function: instrumentationOnRequestError
Function Size: 1106 characters
Questions Generated: 1
Repository: Unknown
Function Preview: // Function: instrumentationOnRequestError (TypeScript)\n// Handles instrumentation errors for requests in both edge and node runtimes.\n\npublic async instrumentationOnRequestError(\n    req: IncomingMessage | BaseNextRequest,\n    ...args: Parameters<InstrumentationOnRequestError>\n  ) {\n    if (process
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T03:37:13.607Z
Question Type: function-variant
Function: loadManifests
Function Size: 7411 characters
Questions Generated: 1
Repository: Unknown
Function Preview: // Function: loadManifests (TypeScript)\n// Loads various manifests based on the runtime environment and source page.\n\nprivate loadManifests(\n    srcPage: string,\n    projectDir?: string\n  ): {\n    buildId: string\n    buildManifest: BuildManifest\n    fallbackBuildManifest: BuildManifest\n    routesMan
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T03:37:16.251Z
Question Type: function-variant
Function: parseSetCookie
Function Size: 613 characters
Questions Generated: 1
Repository: Unknown
Function Preview: // Function: parseSetCookie (TypeScript)\n// Parses a Set-Cookie header value into a ResponseCookie object.\n\ndeclare function parseSetCookie(setCookie: string): undefined | ResponseCookie {\n    const cookieParts = setCookie.split('; ');\n    const [nameValue, ...attributes] = cookieParts;\n    const [n
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T03:37:17.083Z
Question Type: true-false
Function: createModuleContext
Function Size: 2642 characters
Questions Generated: 1
Repository: Unknown
Function Preview: // Function: createModuleContext (TypeScript)\n// Creates a module context with runtime and error handling\n\nasync function createModuleContext(options: ModuleContextOptions) {\n  const warnedEvals = new Set<string>()\n  const warnedWasmCodegens = new Set<string>()\n  const { edgeFunctionEntry } = option
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T03:37:23.372Z
Question Type: multiple-choice
Function: parseCookie
Function Size: 432 characters
Questions Generated: 3
Repository: Unknown
Function Preview: // Function: parseCookie (TypeScript)\n// Parses a Cookie header value into a Map of cookie name-value pairs.\n\ndeclare function parseCookie(cookie: string): Map<string, string> {\n    const result = new Map<string, string>();\n    const cookies = cookie.split('; ');\n    for (const cookie of cookies) {\n
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T03:37:30.944Z
Question Type: order-sequence
Function: buildEnvironmentVariablesFrom
Function Size: 522 characters
Questions Generated: 1
Repository: Unknown
Function Preview: // Function: buildEnvironmentVariablesFrom (TypeScript)\n// Builds environment variables from injected environments and process.env\n\nfunction buildEnvironmentVariablesFrom(\n  injectedEnvironments: Record<string, string>\n): Record<string, string | undefined> {\n  const pairs = Object.keys(process.env).
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T03:37:31.254Z
Question Type: function-variant
Function: throwUnsupportedAPIError
Function Size: 409 characters
Questions Generated: 1
Repository: Unknown
Function Preview: // Function: throwUnsupportedAPIError (TypeScript)\n// Throws an error for unsupported Node.js APIs in Edge Runtime\n\nfunction throwUnsupportedAPIError(name: string) {\n  const error =\n    new Error(`A Node.js API is used (${name}) which is not supported in the Edge Runtime.\nLearn more: https://nextjs.
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T03:37:38.892Z
Question Type: multiple-choice
Function: closeSpanWithError
Function Size: 490 characters
Questions Generated: 3
Repository: Unknown
Function Preview: // Function: closeSpanWithError (TypeScript)\n// Closes a span and records an error if present, setting appropriate attributes.\n\nconst closeSpanWithError = (span: Span, error?: Error) => {\n  if (isBubbledError(error) && error.bubble) {\n    span.setAttribute('next.bubble', true)\n  } else {\n    if (err
================================================================================


=== SESSION SUMMARY ===
Session ID: session-1760067316498
Repository: Unknown
Total Questions Generated: 14
Total Chunks Processed: 12
Ended: 2025-10-10T03:37:48.102Z
================================================================================

