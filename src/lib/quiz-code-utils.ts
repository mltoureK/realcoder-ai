import { createHash } from 'crypto';

export interface ParsedRepositoryFile {
  name: string;
  content: string;
  score: number;
}

/**
 * Normalize combined code string so each file header becomes "// path"
 * Handles headers generated by FileProcessor (with ===== and language hints)
 * as well as the simpler "// path" format used on the client.
 */
function normalizeCombinedCode(code: string): string {
  return code.replace(
    /^\/\/\s*=+\s*([^(\n]+?)(?:\s*\([^)]*\))?\s*=+\s*$/gm,
    (_, path: string) => `// ${path.trim()}`
  );
}

/**
 * Parse combined repository code back into discrete file entries scored for relevance.
 */
export function parseCombinedCode(code: string): ParsedRepositoryFile[] {
  const normalized = normalizeCombinedCode(code);
  const fileRegex = /\/\/\s+([^\n]+)\n([\s\S]*?)(?=\/\/\s+[^\n]+\n|$)/g;
  const parsedFiles: ParsedRepositoryFile[] = [];

  let match: RegExpExecArray | null;
  while ((match = fileRegex.exec(normalized)) !== null) {
    const filename = match[1].trim();
    const content = match[2].trim();
    if (!filename || !content) continue;

    let score = 10;
    if (filename.endsWith('.ts') || filename.endsWith('.tsx')) score += 30;
    if (filename.endsWith('.js') || filename.endsWith('.jsx')) score += 20;
    const functionCount = (content.match(/function\s+\w+|const\s+\w+\s*=\s*\(|class\s+\w+/g) || []).length;
    score += functionCount * 10;

    parsedFiles.push({ name: filename, content, score });
  }

  return parsedFiles;
}

/**
 * Build a stable cache key for prefetched quiz data.
 */
export function makePrefetchKey(
  repositoryInfo: { owner?: string; repo?: string; branch?: string } | null | undefined,
  code: string
): string {
  const owner = repositoryInfo?.owner?.toLowerCase() ?? 'anonymous';
  const repo = repositoryInfo?.repo?.toLowerCase() ?? 'upload';
  const branch = repositoryInfo?.branch?.toLowerCase() ?? 'main';
  const hash = createHash('sha256').update(code).digest('hex');
  return `${owner}/${repo}@${branch}#${hash}`;
}

