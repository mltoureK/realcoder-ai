=== FUNCTION EXTRACTION & QUESTION GENERATION LOG ===
Session ID: session-1760068773889
Started: 2025-10-10T03:59:33.889Z


--- FUNCTION EXTRACTION ---
Timestamp: 2025-10-10T03:59:33.890Z
File: the API is ~stable, so this should be fine
Functions Extracted: 2


Function 1: closeSpanWithError
Language: TypeScript
Lines: 10
Full Code:
--------------------------------------------------------------------------------
const closeSpanWithError = (span: Span, error?: Error) => {
  if (isBubbledError(error) && error.bubble) {
    span.setAttribute('next.bubble', true)
  } else {
    if (error) {
      span.recordException(error)
      span.setAttribute('error.type', error.name)
    }
    span.setStatus({ code: SpanStatusCode.ERROR, message: error?.message })
  }
  span.end()
}
--------------------------------------------------------------------------------


Function 2: getTracePropagationData
Language: TypeScript
Lines: 6
Full Code:
--------------------------------------------------------------------------------
public getTracePropagationData(): ClientTraceDataEntry[] {
    const activeContext = context.active()
    const entries: ClientTraceDataEntry[] = []
    propagation.inject(activeContext, entries, clientTraceDataSetter)
    return entries
}
--------------------------------------------------------------------------------

================================================================================

--- FUNCTION EXTRACTION ---
Timestamp: 2025-10-10T03:59:46.585Z
File: vercel-next.js-0a7811c/packages/next/src/compiled/@edge-runtime/cookies/index.d.ts
Functions Extracted: 3


Function 1: stringifyCookie
Language: TypeScript
Lines: 11
Full Code:
--------------------------------------------------------------------------------
function stringifyCookie(c: ResponseCookie | RequestCookie): string {
    const cookieParts: string[] = [];
    cookieParts.push(`${c.name}=${c.value}`);
    if (c.domain) cookieParts.push(`Domain=${c.domain}`);
    if (c.path) cookieParts.push(`Path=${c.path}`);
    if (c.expires) cookieParts.push(`Expires=${new Date(c.expires).toUTCString()}`);
    if (c.httpOnly) cookieParts.push(`HttpOnly`);
    if (c.secure) cookieParts.push(`Secure`);
    if (c.sameSite) cookieParts.push(`SameSite=${c.sameSite}`);
    return cookieParts.join('; ');
}
--------------------------------------------------------------------------------


Function 2: parseCookie
Language: TypeScript
Lines: 8
Full Code:
--------------------------------------------------------------------------------
function parseCookie(cookie: string): Map<string, string> {
    const result = new Map<string, string>();
    const cookies = cookie.split('; ');
    for (const cookie of cookies) {
        const [name, ...rest] = cookie.split('=');
        const value = rest.join('=');
        result.set(name, decodeURIComponent(value));
    }
    return result;
}
--------------------------------------------------------------------------------


Function 3: parseSetCookie
Language: TypeScript
Lines: 18
Full Code:
--------------------------------------------------------------------------------
function parseSetCookie(setCookie: string): undefined | ResponseCookie {
    const cookieParts = setCookie.split('; ');
    const [nameValue, ...attributes] = cookieParts;
    const [name, value] = nameValue.split('=');
    const cookie: ResponseCookie = { name, value };
    for (const attr of attributes) {
        const [key, val] = attr.split('=');
        switch (key.toLowerCase()) {
            case 'expires':
                cookie.expires = new Date(val);
                break;
            case 'max-age':
                cookie.maxAge = parseInt(val, 10);
                break;
            case 'httponly':
                cookie.httpOnly = true;
                break;
            case 'secure':
                cookie.secure = true;
                break;
            case 'samesite':
                cookie.sameSite = val;
                break;
            case 'path':
                cookie.path = val;
                break;
            case 'domain':
                cookie.domain = val;
                break;
            case 'partitioned':
                cookie.partitioned = true;
                break;
            case 'priority':
                cookie.priority = val as 'low' | 'medium' | 'high';
                break;
        }
    }
    return cookie;
}
--------------------------------------------------------------------------------

================================================================================

--- FUNCTION EXTRACTION ---
Timestamp: 2025-10-10T04:00:06.282Z
File: @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BufferSource'.
Functions Extracted: 4


Function 1: buildEnvironmentVariablesFrom
Language: TypeScript
Lines: 10
Full Code:
--------------------------------------------------------------------------------
function buildEnvironmentVariablesFrom(
  injectedEnvironments: Record<string, string>
): Record<string, string | undefined> {
  const pairs = Object.keys(process.env).map((key) => [key, process.env[key]])
  const env = Object.fromEntries(pairs)
  for (const key of Object.keys(injectedEnvironments)) {
    env[key] = injectedEnvironments[key]
  }
  env.NEXT_RUNTIME = 'edge'
  return env
}
--------------------------------------------------------------------------------


Function 2: throwUnsupportedAPIError
Language: TypeScript
Lines: 6
Full Code:
--------------------------------------------------------------------------------
function throwUnsupportedAPIError(name: string) {
  const error =
    new Error(`A Node.js API is used (${name}) which is not supported in the Edge Runtime.
Learn more: https://nextjs.org/docs/api-reference/edge-runtime`)
  decorateServerError(error, COMPILER_NAMES.edgeServer)
  throw error
}
--------------------------------------------------------------------------------


Function 3: createProcessPolyfill
Language: TypeScript
Lines: 15
Full Code:
--------------------------------------------------------------------------------
function createProcessPolyfill(env: Record<string, string>) {
  const processPolyfill = { env: buildEnvironmentVariablesFrom(env) }
  const overriddenValue: Record<string, any> = {}

  for (const key of Object.keys(process)) {
    if (key === 'env') continue
    Object.defineProperty(processPolyfill, key, {
      get() {
        if (overriddenValue[key] !== undefined) {
          return overriddenValue[key]
        }
        if (typeof (process as any)[key] === 'function') {
          return () => throwUnsupportedAPIError(`process.${key}`)
        }
        return undefined
      },
      set(value) {
        overriddenValue[key] = value
      },
      enumerable: false,
    })
  }
  return processPolyfill
}
--------------------------------------------------------------------------------


Function 4: createModuleContext
Language: TypeScript
Lines: 40
Full Code:
--------------------------------------------------------------------------------
async function createModuleContext(options: ModuleContextOptions) {
  const warnedEvals = new Set<string>()
  const warnedWasmCodegens = new Set<string>()
  const { edgeFunctionEntry } = options
  const wasm = await loadWasm(edgeFunctionEntry.wasm ?? [])
  const runtime = new EdgeRuntime({
    codeGeneration:
      process.env.NODE_ENV !== 'production'
        ? { strings: true, wasm: true }
        : undefined,
    extend: (context) => {
      context.process = createProcessPolyfill(edgeFunctionEntry.env)

      Object.defineProperty(context, 'require', {
        enumerable: false,
        value: (id: string) => {
          const value = NativeModuleMap.get(id)
          if (!value) {
            throw TypeError('Native module not found: ' + id)
          }
          return value
        },
      })

      if (process.env.NODE_ENV !== 'production') {
        context.__next_log_error__ = function (err: unknown) {
          options.onError(err)
        }
      }

      context.__next_eval__ = function __next_eval__(fn: Function) {
        const key = fn.toString()
        if (!warnedEvals.has(key)) {
          const warning = getServerError(
            new Error(
              `Dynamic Code Evaluation (e. g. 'eval', 'new Function') not allowed in Edge Runtime
Learn More: https://nextjs.org/docs/messages/edge-dynamic-code-evaluation`
            ),
            COMPILER_NAMES.edgeServer
          )
          warning.name = 'DynamicCodeEvaluationWarning'
          Error.captureStackTrace(warning, __next_eval__)
          warnedEvals.add(key)
          options.onWarning(warning)
        }
        return fn()
      }

      context.__next_webassembly_compile__ =
        function __next_webassembly_compile__(fn: Function) {
          const key = fn.toString()
          if (!warnedWasmCodegens.has(key)) {
            const warning = getServerError(
              new Error(`Dynamic WASM code generation (e. g. 'WebAssembly.compile') not allowed in Edge Runtime.
Learn More: https://nextjs.org/docs/messages/edge-dynamic-code-evaluation`),
              COMPILER_NAMES.edgeServer
            )
            warning.name = 'DynamicWasmCodeGenerationWarning'
            Error.captureStackTrace(warning, __next_webassembly_compile__)
            warnedWasmCodegens.add(key)
            options.onWarning(warning)
          }
          return fn()
        }

      context.__next_webassembly_instantiate__ =
        async function __next_webassembly_instantiate__(fn: Function) {
          const result = await fn()
--------------------------------------------------------------------------------

================================================================================

--- FUNCTION EXTRACTION ---
Timestamp: 2025-10-10T04:00:11.879Z
File: This keeps autocompletion working for static routes.
Functions Extracted: 1


Function 1: generateValidatorFile
Language: TypeScript
Lines: 15
Full Code:
--------------------------------------------------------------------------------
export function generateValidatorFile(
  routesManifest: RouteTypesManifest
): string {
  const generateValidations = (
    paths: string[],
    type:
      | 'AppPageConfig'
      | 'PagesPageConfig'
      | 'LayoutConfig'
      | 'RouteHandlerConfig'
      | 'ApiRouteConfig',
    pathToRouteMap?: Map<string, string>
  ) =>
    paths
      .sort()
      .map((path) => {
        const route = pathToRouteMap ? pathToRouteMap.get(path) : undefined;
        return `${type} ${path} ${route ? `-> ${route}` : ''}`;
      })
      .join('\n');

  return generateValidations(Object.keys(routesManifest.routes), 'AppPageConfig');
}
--------------------------------------------------------------------------------

================================================================================

--- FUNCTION EXTRACTION ---
Timestamp: 2025-10-10T04:00:56.132Z
File: vercel-next.js-0a7811c/packages/next/src/server/route-modules/route-module.ts
Functions Extracted: 1


Function 1: loadManifests
Language: TypeScript
Lines: 68
Full Code:
--------------------------------------------------------------------------------
private loadManifests(srcPage: string, projectDir?: string) {
    if (process.env.NEXT_RUNTIME === 'edge') {
      const { getEdgePreviewProps } =
        require('../web/get-edge-preview-props') as typeof import('../web/get-edge-preview-props');

      const maybeJSONParse = (str?: string) =>
        str ? JSON.parse(str) : undefined;

      return {
        buildId: process.env.__NEXT_BUILD_ID || '',
        buildManifest: self.__BUILD_MANIFEST as any,
        fallbackBuildManifest: {} as any,
        reactLoadableManifest: maybeJSONParse(self.__REACT_LOADABLE_MANIFEST),
        nextFontManifest: maybeJSONParse(self.__NEXT_FONT_MANIFEST),
        prerenderManifest: {
          routes: {},
          dynamicRoutes: {},
          notFoundRoutes: [],
          version: 4,
          preview: getEdgePreviewProps(),
        },
        routesManifest: {
          version: 4,
          caseSensitive: Boolean(process.env.__NEXT_CASE_SENSITIVE_ROUTES),
          basePath: process.env.__NEXT_BASE_PATH || '',
          rewrites: (process.env.__NEXT_REWRITES as any) || {
            beforeFiles: [],
            afterFiles: [],
            fallback: [],
          },
          redirects: [],
          headers: [],
          i18n:
            (process.env.__NEXT_I18N_CONFIG as any as I18NConfig) || undefined,
          skipMiddlewareUrlNormalize: Boolean(
            process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE
          ),
        },
        serverFilesManifest: {
          config: (globalThis as any).nextConfig || {},
        } as any,
        clientReferenceManifest: self.__RSC_MANIFEST?.[srcPage],
        serverActionsManifest: maybeJSONParse(self.__RSC_SERVER_MANIFEST),
        subresourceIntegrityManifest: maybeJSONParse(
          self.__SUBRESOURCE_INTEGRITY_MANIFEST
        ),
        dynamicCssManifest: maybeJSONParse(self.__DYNAMIC_CSS_MANIFEST),
        interceptionRoutePatterns: (
          maybeJSONParse(self.__INTERCEPTION_ROUTE_REWRITE_MANIFEST) ?? []
        ).map((rewrite: any) => new RegExp(rewrite.regex)),
      };
    } else {
      if (!projectDir) {
        throw new Error('Invariant: projectDir is required for node runtime');
      }
      const { loadManifestFromRelativePath } =
        require('../load-manifest.external') as typeof import('../load-manifest.external');
      const normalizedPagePath = normalizePagePath(srcPage);

      const router =
        this.definition.kind === RouteKind.PAGES ||
        this.definition.kind === RouteKind.PAGES_API
          ? 'pages'
          : 'app';

      const [
        routesManifest,
        prerenderManifest,
        buildManifest,
        fallbackBuildManifest,
        reactLoadableManifest,
        nextFontManifest,
        clientReferenceManifest,
        serverActionsManifest,
        subresourceIntegrityManifest,
        serverFilesManifest,
        buildId,
        dynamicCssManifest,
      ] = [
        loadManifestFromRelativePath<DevRoutesManifest>({
          projectDir,
          distDir: this.distDir,
          manifest: ROUTES_MANIFEST,
          shouldCache: !this.isDev,
        }),
        loadManifestFromRelativePath<PrerenderManifest>({
          projectDir,
          distDir: this.distDir,
          manifest: PRERENDER_MANIFEST,
          shouldCache: !this.isDev,
        }),
        loadManifestFromRelativePath<BuildManifest>({
          projectDir,
          distDir: this.distDir,
          manifest: BUILD_MANIFEST,
          shouldCache: !this.isDev,
        }),
        srcPage === '/_error'
          ? loadManifestFromRelativePath<BuildManifest>({
              projectDir,
              distDir: this.distDir,
              manifest: `fallback-${BUILD_MANIFEST}`,
              shouldCache: !this.isDev,
              handleMissing: true,
            })
          : ({} as BuildManifest),
        loadManifestFromRelativePath<ReactLoadableManifest>({
          projectDir,
          distDir: this.distDir,
          manifest: process.env.TURBOPACK
            ? `server/${router === 'app' ? 'app' : 'pages'}${normalizedPagePath}/${REACT_LOADABLE_MANIFEST}`
            : REACT_LOADABLE_MANIFEST,
          handleMissing: true,
          shouldCache: !this.isDev,
        }),
        loadManifestFromRelativePath<NextFontManifest>({
          projectDir,
          distDir: this.distDir,
          manifest: `server/${NEXT_FONT_MANIFEST}.json`,
          shouldCache: !this.isDev,
        }),
        router === 'app' && !isStaticMetadataRoute(srcPage)
          ? loadManifestFromRelativePath({
              distDir: this.distDir,
              projectDir,
              useEval: true,
              handleMissing: true,
              manifest: `server/app${srcPage.replace(/%5F/g, '_') + '_' + CLIENT_REFERENCE_MANIFEST}.js`,
              shouldCache: !this.isDev,
            })
          : undefined,
        router === 'app'
          ? loadManifestFromRelativePath<any>({
              distDir: this.distDir,
              projectDir,
              manifest: `server/${SERVER_REFERENCE_MANIFEST}.json`,
              handleMissing: true,
              shouldCache: !this.isDev,
            })
          : {},
        loadManifestFromRelativePath<Record<string, string>>({
          projectDir,
          distDir: this.distDir,
          manifest: `server/${SUBRESOURCE_INTEGRITY_MANIFEST}.json`,
          handleMissing: true,
          shouldCache: !this.isDev,
        }),
        this.isDev
          ? ({} as any)
          : loadManifestFromRelativePath<RequiredServerFilesManifest>({
              projectDir,
              distDir: this.distDir,
              manifest: SERVER_FILES_MANIFEST,
            }),
        this.isDev
          ? 'development'
          : loadManifestFromRelativePath<any>({
              projectDir,
              distDir: this.distDir,
              manifest: BUILD_ID_FILE,
              skipParse: true,
            }),
        loadManifestFromRelativePath<any>({
          projectDir,
          distDir: this.distDir,
          manifest: DYNAMIC_CSS_MANIFEST,
          handleMissing: true,
        }),
      ];

      return {
        buildId,
        buildManifest,
        fallbackBuildManifest,
        routesManifest,
        nextFontManifest,
        prerenderManifest,
        serverFilesManifest,
        reactLoadableManifest,
        clientReferenceManifest: (clientReferenceManifest as any)
          ?.__RSC_MANIFEST?.[srcPage.replace(/%5F/g, '_')],
        serverActionsManifest,
        subresourceIntegrityManifest,
        dynamicCssManifest,
        interceptionRoutePatterns: routesManifest.rewrites.beforeFiles
          .filter(isInterceptionRouteRewrite)
          .map((rewrite) => new RegExp(rewrite.regex)),
      };
    }
  }
--------------------------------------------------------------------------------

================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T04:01:03.395Z
Question Type: true-false
Function: buildEnvironmentVariablesFrom
Function Size: 523 characters
Questions Generated: 1
Repository: Unknown
Function Preview: // Function: buildEnvironmentVariablesFrom (TypeScript)\n// Builds environment variables from injected environments and process.env.\n\nfunction buildEnvironmentVariablesFrom(\n  injectedEnvironments: Record<string, string>\n): Record<string, string | undefined> {\n  const pairs = Object.keys(process.env)
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T04:01:04.004Z
Question Type: true-false
Function: throwUnsupportedAPIError
Function Size: 410 characters
Questions Generated: 1
Repository: Unknown
Function Preview: // Function: throwUnsupportedAPIError (TypeScript)\n// Throws an error for unsupported Node.js APIs in Edge Runtime.\n\nfunction throwUnsupportedAPIError(name: string) {\n  const error =\n    new Error(`A Node.js API is used (${name}) which is not supported in the Edge Runtime.\nLearn more: https://nextjs
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T04:01:10.192Z
Question Type: order-sequence
Function: getTracePropagationData
Function Size: 360 characters
Questions Generated: 1
Repository: Unknown
Function Preview: // Function: getTracePropagationData (TypeScript)\n// Retrieves trace propagation data for the currently active context.\n\npublic getTracePropagationData(): ClientTraceDataEntry[] {\n    const activeContext = context.active()\n    const entries: ClientTraceDataEntry[] = []\n    propagation.inject(activeC
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T04:01:13.725Z
Question Type: multiple-choice
Function: stringifyCookie
Function Size: 666 characters
Questions Generated: 1
Repository: Unknown
Function Preview: // Function: stringifyCookie (TypeScript)\n// Converts a cookie object into a string suitable for the Set-Cookie header.\n\nfunction stringifyCookie(c: ResponseCookie | RequestCookie): string {\n    const cookieParts: string[] = [];\n    cookieParts.push(`${c.name}=${c.value}`);\n    if (c.domain) cookieP
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T04:01:15.534Z
Question Type: select-all
Function: parseCookie
Function Size: 460 characters
Questions Generated: 1
Repository: Unknown
Function Preview: // Function: parseCookie (TypeScript)\n// Parses a Cookie header value into a Map of cookie names and values.\n\nfunction parseCookie(cookie: string): Map<string, string> {\n    const result = new Map<string, string>();\n    const cookies = cookie.split('; ');\n    for (const cookie of cookies) {\n        
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T04:01:23.624Z
Question Type: multiple-choice
Function: parseCookie
Function Size: 460 characters
Questions Generated: 3
Repository: Unknown
Function Preview: // Function: parseCookie (TypeScript)\n// Parses a Cookie header value into a Map of cookie names and values.\n\nfunction parseCookie(cookie: string): Map<string, string> {\n    const result = new Map<string, string>();\n    const cookies = cookie.split('; ');\n    for (const cookie of cookies) {\n        
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T04:01:24.381Z
Question Type: multiple-choice
Function: createProcessPolyfill
Function Size: 839 characters
Questions Generated: 0
Repository: Unknown
Function Preview: // Function: createProcessPolyfill (TypeScript)\n// Creates a polyfill for the process object with overridden properties.\n\nfunction createProcessPolyfill(env: Record<string, string>) {\n  const processPolyfill = { env: buildEnvironmentVariablesFrom(env) }\n  const overriddenValue: Record<string, any> =
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T04:01:24.473Z
Question Type: function-variant
Function: closeSpanWithError
Function Size: 485 characters
Questions Generated: 0
Repository: Unknown
Function Preview: // Function: closeSpanWithError (TypeScript)\n// Closes a span with error handling and attributes based on the error type.\n\nconst closeSpanWithError = (span: Span, error?: Error) => {\n  if (isBubbledError(error) && error.bubble) {\n    span.setAttribute('next.bubble', true)\n  } else {\n    if (error) {
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T04:01:33.803Z
Question Type: multiple-choice
Function: getTracePropagationData
Function Size: 360 characters
Questions Generated: 0
Repository: Unknown
Function Preview: // Function: getTracePropagationData (TypeScript)\n// Retrieves trace propagation data for the currently active context.\n\npublic getTracePropagationData(): ClientTraceDataEntry[] {\n    const activeContext = context.active()\n    const entries: ClientTraceDataEntry[] = []\n    propagation.inject(activeC
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T04:01:39.108Z
Question Type: select-all
Function: loadManifests
Function Size: 6861 characters
Questions Generated: 1
Repository: Unknown
Function Preview: // Function: loadManifests (TypeScript)\n// Loads various manifests based on the runtime environment and source page.\n\nprivate loadManifests(srcPage: string, projectDir?: string) {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      const { getEdgePreviewProps } =\n        require('../web/get-edge-pr
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T04:01:41.902Z
Question Type: multiple-choice
Function: buildEnvironmentVariablesFrom
Function Size: 523 characters
Questions Generated: 3
Repository: Unknown
Function Preview: // Function: buildEnvironmentVariablesFrom (TypeScript)\n// Builds environment variables from injected environments and process.env.\n\nfunction buildEnvironmentVariablesFrom(\n  injectedEnvironments: Record<string, string>\n): Record<string, string | undefined> {\n  const pairs = Object.keys(process.env)
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T04:01:44.247Z
Question Type: multiple-choice
Function: closeSpanWithError
Function Size: 485 characters
Questions Generated: 0
Repository: Unknown
Function Preview: // Function: closeSpanWithError (TypeScript)\n// Closes a span with error handling and attributes based on the error type.\n\nconst closeSpanWithError = (span: Span, error?: Error) => {\n  if (isBubbledError(error) && error.bubble) {\n    span.setAttribute('next.bubble', true)\n  } else {\n    if (error) {
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T04:01:48.343Z
Question Type: multiple-choice
Function: createModuleContext
Function Size: 2645 characters
Questions Generated: 3
Repository: Unknown
Function Preview: // Function: createModuleContext (TypeScript)\n// Creates a module context with a runtime context and caches.\n\nasync function createModuleContext(options: ModuleContextOptions) {\n  const warnedEvals = new Set<string>()\n  const warnedWasmCodegens = new Set<string>()\n  const { edgeFunctionEntry } = opt
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T04:01:48.744Z
Question Type: function-variant
Function: createModuleContext
Function Size: 2645 characters
Questions Generated: 0
Repository: Unknown
Function Preview: // Function: createModuleContext (TypeScript)\n// Creates a module context with a runtime context and caches.\n\nasync function createModuleContext(options: ModuleContextOptions) {\n  const warnedEvals = new Set<string>()\n  const warnedWasmCodegens = new Set<string>()\n  const { edgeFunctionEntry } = opt
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T04:01:53.236Z
Question Type: multiple-choice
Function: loadManifests
Function Size: 6861 characters
Questions Generated: 0
Repository: Unknown
Function Preview: // Function: loadManifests (TypeScript)\n// Loads various manifests based on the runtime environment and source page.\n\nprivate loadManifests(srcPage: string, projectDir?: string) {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      const { getEdgePreviewProps } =\n        require('../web/get-edge-pr
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T04:01:54.879Z
Question Type: multiple-choice
Function: generateValidatorFile
Function Size: 737 characters
Questions Generated: 3
Repository: Unknown
Function Preview: // Function: generateValidatorFile (TypeScript)\n// Generates a validator file based on the routes manifest.\n\nexport function generateValidatorFile(\n  routesManifest: RouteTypesManifest\n): string {\n  const generateValidations = (\n    paths: string[],\n    type:\n      | 'AppPageConfig'\n      | 'PagesPa
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T04:02:00.460Z
Question Type: multiple-choice
Function: parseSetCookie
Function Size: 1394 characters
Questions Generated: 2
Repository: Unknown
Function Preview: // Function: parseSetCookie (TypeScript)\n// Parses a Set-Cookie header value into a ResponseCookie object.\n\nfunction parseSetCookie(setCookie: string): undefined | ResponseCookie {\n    const cookieParts = setCookie.split('; ');\n    const [nameValue, ...attributes] = cookieParts;\n    const [name, val
================================================================================

--- QUESTION GENERATION ---
Timestamp: 2025-10-10T04:02:04.541Z
Question Type: order-sequence
Function: generateValidatorFile
Function Size: 737 characters
Questions Generated: 1
Repository: Unknown
Function Preview: // Function: generateValidatorFile (TypeScript)\n// Generates a validator file based on the routes manifest.\n\nexport function generateValidatorFile(\n  routesManifest: RouteTypesManifest\n): string {\n  const generateValidations = (\n    paths: string[],\n    type:\n      | 'AppPageConfig'\n      | 'PagesPa
================================================================================


=== SESSION SUMMARY ===
Session ID: session-1760068773889
Repository: Unknown
Total Questions Generated: 21
Total Chunks Processed: 11
Ended: 2025-10-10T04:02:07.499Z
================================================================================

